
** Conflict (shift/reduce) in state 131.
** Token involved: ELSE
** This state is reached from file after reading:

typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP LB list(terminated(decl_var,SEMI)) IF LP expr RP IF LP expr RP instr 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

file 
list(decl) EOF 
decl list(decl) 
typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP block 
                                                               LB list(terminated(decl_var,SEMI)) list(instr) RB 
                                                                                                  instr list(instr) 
                                                                                                  instr_ 
                                                                                                  (?)

** In state 131, looking ahead at ELSE, shifting is permitted
** because of the following sub-derivation:

IF LP expr RP instr ELSE instr 
              instr_ 
              IF LP expr RP instr . ELSE instr 

** In state 131, looking ahead at ELSE, reducing production
** instr_ -> IF LP expr RP instr 
** is permitted because of the following sub-derivation:

IF LP expr RP instr ELSE instr // lookahead token appears
              instr_ // lookahead token is inherited
              IF LP expr RP instr . 

** Conflict (shift/reduce) in state 123.
** Tokens involved: SIZEOF PP PLUS MULT MM MINUS LP IDENT CONST_STRING CONST_DOUBLE CONST_CHAR CINT
** The following explanations concentrate on token SIZEOF.
** This state is reached from file after reading:

typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP LB list(terminated(decl_var,SEMI)) FOR LP l_expr 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

file 
list(decl) EOF 
decl list(decl) 
typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP block 
                                                               LB list(terminated(decl_var,SEMI)) list(instr) RB 
                                                                                                  instr list(instr) 
                                                                                                  instr_ 
                                                                                                  (?)

** In state 123, looking ahead at SIZEOF, shifting is permitted
** because of the following sub-derivation:

FOR LP l_expr option(expr) l_expr RP instr 
              expr 
              expr_ 
              . SIZEOF LP cplx_type RP 

** In state 123, looking ahead at SIZEOF, reducing production
** option(expr) -> 
** is permitted because of the following sub-derivation:

FOR LP l_expr option(expr) l_expr RP instr // lookahead token appears because l_expr can begin with SIZEOF
              . 

** Conflict (shift/reduce) in state 122.
** Tokens involved: SIZEOF PP PLUS MULT MM MINUS LP IDENT CONST_STRING CONST_DOUBLE CONST_CHAR CINT
** The following explanations concentrate on token SIZEOF.
** This state is reached from file after reading:

typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP LB list(terminated(decl_var,SEMI)) FOR LP 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

file 
list(decl) EOF 
decl list(decl) 
typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP block 
                                                               LB list(terminated(decl_var,SEMI)) list(instr) RB 
                                                                                                  instr list(instr) 
                                                                                                  instr_ 
                                                                                                  (?)

** In state 122, looking ahead at SIZEOF, shifting is permitted
** because of the following sub-derivation:

FOR LP l_expr option(expr) l_expr RP instr 
       loption(separated_nonempty_list(COMMA,expr)) 
       separated_nonempty_list(COMMA,expr) 
       expr 
       expr_ 
       . SIZEOF LP cplx_type RP 

** In state 122, looking ahead at SIZEOF, reducing production
** loption(separated_nonempty_list(COMMA,expr)) -> 
** is permitted because of the following sub-derivation:

FOR LP l_expr option(expr) l_expr RP instr // lookahead token appears because option(expr) can begin with SIZEOF
       loption(separated_nonempty_list(COMMA,expr)) // lookahead token is inherited
       . 

** Conflict (shift/reduce) in state 116.
** Tokens involved: PP PLUS MULT MM MINUS
** The following explanations concentrate on token PP.
** This state is reached from file after reading:

typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP LB list(terminated(decl_var,SEMI)) WHILE expr 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

file 
list(decl) EOF 
decl list(decl) 
typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP block 
                                                               LB list(terminated(decl_var,SEMI)) list(instr) RB 
                                                                                                  instr list(instr) 
                                                                                                  instr_ 
                                                                                                  (?)

** In state 116, looking ahead at PP, shifting is permitted
** because of the following sub-derivation:

WHILE option(expr) instr 
      expr 
      expr_ 
      expr . PP 

** In state 116, looking ahead at PP, reducing production
** option(expr) -> expr 
** is permitted because of the following sub-derivation:

WHILE option(expr) instr // lookahead token appears because instr can begin with PP
      expr . 

** Conflict (shift/reduce) in state 110.
** Tokens involved: PP POINTER PLUS OR NEQ MULT MODULO MM MINUS LT LE LBRACKET GT GE EQ DOT DIV ASSIGN AND
** The following explanations concentrate on token PP.
** This state is reached from file after reading:

typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP LB list(terminated(decl_var,SEMI)) PP expr 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

file 
list(decl) EOF 
decl list(decl) 
typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP block 
                                                               LB list(terminated(decl_var,SEMI)) list(instr) RB 
                                                                                                  instr list(instr) 
                                                                                                  instr_ 
                                                                                                  expr SEMI 
                                                                                                  expr_ 
                                                                                                  (?)

** In state 110, looking ahead at PP, reducing production
** expr_ -> PP expr 
** is permitted because of the following sub-derivation:

expr PP // lookahead token appears
expr_ // lookahead token is inherited
PP expr . 

** In state 110, looking ahead at PP, shifting is permitted
** because of the following sub-derivation:

PP expr 
   expr_ 
   expr . PP 

** Conflict (reduce/reduce) in state 109.
** Tokens involved: PP POINTER PLUS OR NEQ MULT MODULO MM MINUS LT LE LBRACKET GT GE EQ DOT DIV ASSIGN AND
** The following explanations concentrate on token PP.
** This state is reached from file after reading:

typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP LB list(terminated(decl_var,SEMI)) PLUS expr_ 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

file 
list(decl) EOF 
decl list(decl) 
typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP block 
                                                               LB list(terminated(decl_var,SEMI)) list(instr) RB 
                                                                                                  instr list(instr) 
                                                                                                  instr_ 
                                                                                                  expr SEMI 
                                                                                                  expr_ 
                                                                                                  (?)

** In state 109, looking ahead at PP, reducing production
** expr -> expr_ 
** is permitted because of the following sub-derivation:

PLUS expr_ 
     expr PP // lookahead token appears
     expr_ . 

** In state 109, looking ahead at PP, reducing production
** expr_ -> PLUS expr_ 
** is permitted because of the following sub-derivation:

expr PP // lookahead token appears
expr_ // lookahead token is inherited
PLUS expr_ . 

** Conflict (shift/reduce) in state 108.
** Tokens involved: PP POINTER OR NEQ MODULO MM LT LE LBRACKET GT GE EQ DOT ASSIGN AND
** The following explanations concentrate on token PP.
** This state is reached from file after reading:

typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP LB list(terminated(decl_var,SEMI)) MULT expr 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

file 
list(decl) EOF 
decl list(decl) 
typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP block 
                                                               LB list(terminated(decl_var,SEMI)) list(instr) RB 
                                                                                                  instr list(instr) 
                                                                                                  instr_ 
                                                                                                  expr SEMI 
                                                                                                  expr_ 
                                                                                                  (?)

** In state 108, looking ahead at PP, reducing production
** expr_ -> MULT expr 
** is permitted because of the following sub-derivation:

expr PP // lookahead token appears
expr_ // lookahead token is inherited
MULT expr . 

** In state 108, looking ahead at PP, shifting is permitted
** because of the following sub-derivation:

MULT expr 
     expr_ 
     expr . PP 

** Conflict (shift/reduce) in state 107.
** Tokens involved: PP POINTER PLUS OR NEQ MULT MODULO MM MINUS LT LE LBRACKET GT GE EQ DOT DIV ASSIGN AND
** The following explanations concentrate on token PP.
** This state is reached from file after reading:

typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP LB list(terminated(decl_var,SEMI)) MM expr 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

file 
list(decl) EOF 
decl list(decl) 
typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP block 
                                                               LB list(terminated(decl_var,SEMI)) list(instr) RB 
                                                                                                  instr list(instr) 
                                                                                                  instr_ 
                                                                                                  expr SEMI 
                                                                                                  expr_ 
                                                                                                  (?)

** In state 107, looking ahead at PP, reducing production
** expr_ -> MM expr 
** is permitted because of the following sub-derivation:

expr PP // lookahead token appears
expr_ // lookahead token is inherited
MM expr . 

** In state 107, looking ahead at PP, shifting is permitted
** because of the following sub-derivation:

MM expr 
   expr_ 
   expr . PP 

** Conflict (shift/reduce) in state 106.
** Tokens involved: PP POINTER OR NEQ MODULO MM LT LE LBRACKET GT GE EQ DOT ASSIGN AND
** The following explanations concentrate on token PP.
** This state is reached from file after reading:

typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP LB list(terminated(decl_var,SEMI)) MINUS expr 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

file 
list(decl) EOF 
decl list(decl) 
typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP block 
                                                               LB list(terminated(decl_var,SEMI)) list(instr) RB 
                                                                                                  instr list(instr) 
                                                                                                  instr_ 
                                                                                                  expr SEMI 
                                                                                                  expr_ 
                                                                                                  (?)

** In state 106, looking ahead at PP, reducing production
** expr_ -> MINUS expr 
** is permitted because of the following sub-derivation:

expr PP // lookahead token appears
expr_ // lookahead token is inherited
MINUS expr . 

** In state 106, looking ahead at PP, shifting is permitted
** because of the following sub-derivation:

MINUS expr 
      expr_ 
      expr . PP 

** Conflict (shift/reduce) in state 105.
** Tokens involved: PP POINTER PLUS OR NEQ MULT MODULO MM MINUS LT LE LBRACKET GT GE EQ DOT DIV ASSIGN AND
** The following explanations concentrate on token PP.
** This state is reached from file after reading:

typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP LB list(terminated(decl_var,SEMI)) LP cplx_type RP expr 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

file 
list(decl) EOF 
decl list(decl) 
typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP block 
                                                               LB list(terminated(decl_var,SEMI)) list(instr) RB 
                                                                                                  instr list(instr) 
                                                                                                  instr_ 
                                                                                                  expr SEMI 
                                                                                                  expr_ 
                                                                                                  (?)

** In state 105, looking ahead at PP, shifting is permitted
** because of the following sub-derivation:

LP cplx_type RP expr 
                expr_ 
                expr . PP 

** In state 105, looking ahead at PP, reducing production
** expr_ -> LP cplx_type RP expr 
** is permitted because of the following sub-derivation:

expr PP // lookahead token appears
expr_ // lookahead token is inherited
LP cplx_type RP expr . 

** Conflict (shift/reduce) in state 96.
** Tokens involved: PP POINTER PLUS OR NEQ MULT MODULO MM MINUS LT LE LBRACKET GT GE EQ DOT DIV ASSIGN AND
** The following explanations concentrate on token PP.
** This state is reached from file after reading:

typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP LB list(terminated(decl_var,SEMI)) expr op expr 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

file 
list(decl) EOF 
decl list(decl) 
typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP block 
                                                               LB list(terminated(decl_var,SEMI)) list(instr) RB 
                                                                                                  instr list(instr) 
                                                                                                  instr_ 
                                                                                                  expr SEMI 
                                                                                                  expr_ 
                                                                                                  (?)

** In state 96, looking ahead at PP, reducing production
** expr_ -> expr op expr 
** is permitted because of the following sub-derivation:

expr PP // lookahead token appears
expr_ // lookahead token is inherited
expr op expr . 

** In state 96, looking ahead at PP, shifting is permitted
** because of the following sub-derivation:

expr op expr 
        expr_ 
        expr . PP 

** Conflict (shift/reduce) in state 93.
** Tokens involved: PP POINTER PLUS OR NEQ MULT MODULO MM MINUS LT LE LBRACKET GT GE EQ DOT DIV ASSIGN AND
** The following explanations concentrate on token PP.
** This state is reached from file after reading:

typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP LB list(terminated(decl_var,SEMI)) expr ASSIGN expr 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

file 
list(decl) EOF 
decl list(decl) 
typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP block 
                                                               LB list(terminated(decl_var,SEMI)) list(instr) RB 
                                                                                                  instr list(instr) 
                                                                                                  instr_ 
                                                                                                  expr SEMI 
                                                                                                  expr_ 
                                                                                                  (?)

** In state 93, looking ahead at PP, shifting is permitted
** because of the following sub-derivation:

expr ASSIGN expr 
            expr_ 
            expr . PP 

** In state 93, looking ahead at PP, reducing production
** expr_ -> expr ASSIGN expr 
** is permitted because of the following sub-derivation:

expr PP // lookahead token appears
expr_ // lookahead token is inherited
expr ASSIGN expr . 

** Conflict (shift/reduce) in state 70.
** Tokens involved: PP PLUS MULT MM MINUS
** The following explanations concentrate on token PP.
** This state is reached from file after reading:

typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP LB list(terminated(decl_var,SEMI)) FOR LP expr 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

file 
list(decl) EOF 
decl list(decl) 
typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP block 
                                                               LB list(terminated(decl_var,SEMI)) list(instr) RB 
                                                                                                  instr list(instr) 
                                                                                                  instr_ 
                                                                                                  (?)

** In state 70, looking ahead at PP, shifting is permitted
** because of the following sub-derivation:

FOR LP l_expr option(expr) l_expr RP instr 
       loption(separated_nonempty_list(COMMA,expr)) 
       separated_nonempty_list(COMMA,expr) 
       expr 
       expr_ 
       expr . PP 

** In state 70, looking ahead at PP, reducing production
** separated_nonempty_list(COMMA,expr) -> expr 
** is permitted because of the following sub-derivation:

FOR LP l_expr option(expr) l_expr RP instr // lookahead token appears because option(expr) can begin with PP
       loption(separated_nonempty_list(COMMA,expr)) // lookahead token is inherited
       separated_nonempty_list(COMMA,expr) // lookahead token is inherited
       expr . 

** Conflict (shift/reduce) in state 63.
** Token involved: LP
** This state is reached from file after reading:

typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP LB list(terminated(decl_var,SEMI)) WHILE ident 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

file 
list(decl) EOF 
decl list(decl) 
typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP block 
                                                               LB list(terminated(decl_var,SEMI)) list(instr) RB 
                                                                                                  instr list(instr) 
                                                                                                  instr_ 
                                                                                                  (?)

** In state 63, looking ahead at LP, reducing production
** expr_ -> ident 
** is permitted because of the following sub-derivation:

WHILE option(expr) instr // lookahead token appears because instr can begin with LP
      expr // lookahead token is inherited
      expr_ // lookahead token is inherited
      ident . 

** In state 63, looking ahead at LP, shifting is permitted
** because of the following sub-derivation:

WHILE option(expr) instr 
      expr 
      expr_ 
      ident . LP l_expr RP 

** Conflict (shift/reduce) in state 46.
** Tokens involved: SIZEOF PP PLUS MULT MM MINUS LP IDENT CONST_STRING CONST_DOUBLE CONST_CHAR CINT
** The following explanations concentrate on token SIZEOF.
** This state is reached from file after reading:

typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP LB list(terminated(decl_var,SEMI)) WHILE 

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

file 
list(decl) EOF 
decl list(decl) 
typ var LP loption(separated_nonempty_list(COMMA,decl_var)) RP block 
                                                               LB list(terminated(decl_var,SEMI)) list(instr) RB 
                                                                                                  instr list(instr) 
                                                                                                  instr_ 
                                                                                                  (?)

** In state 46, looking ahead at SIZEOF, shifting is permitted
** because of the following sub-derivation:

WHILE option(expr) instr 
      expr 
      expr_ 
      . SIZEOF LP cplx_type RP 

** In state 46, looking ahead at SIZEOF, reducing production
** option(expr) -> 
** is permitted because of the following sub-derivation:

WHILE option(expr) instr // lookahead token appears because instr can begin with SIZEOF
      . 
